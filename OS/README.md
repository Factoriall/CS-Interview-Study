# OS

+ [Process vs Thread](#Process-VS-Thread)
  * Process + PCB
  * Thread
  * Multi-Thread vs Multi-Process
+ [Synchronization](#Synchronization)
  - 뮤텍스
  - 세마포어
  - 스핀락
  - 모니터
+ [DeadLock](#DeadLock)
+ 메모리 관리 기법
  - [페이징](#페이징)
  - [세그멘테이션](#세그멘테이션)
+ [OSI 7계층](#OSI-7계층)

## Process VS Thread
### 프로세스 + PCB

- 프로그램을 구동하여 프로그램이 메모리 상에서 실행되는 작업 단위
- OS로부터 주소 공간, 파일, 메모리 등을 할당받음

#### 프로세스 구조

![process](../image/os_process.png)

- Code: 실행 프로그램의 코드 영역 및 PC(Program Counter, 다음번 실행될 명령어의 주소를 가지고 있는 레지스터) 저장
- Data: 프로그램 전역변수 & 정적변수 저장
- Heap: 동적으로 메모리 공간을 할당했을 시 저장되는 부분
  + 낮은 주소 -> 높은 주소(FIFO)
- Stack: 매개변수, 복귀 주소 및 로컬 변수 같은 임시 자료를 저장하는 부분
  + 높은 주소 -> 낮은 주소(LIFO)


#### PCB(Process Control Block)
- **특정 프로세스에 대한 중요 정보**를 저장하고 있는 운영 체제의 자료 구조
- 프로세스 생성과 동시에 고유한 PCB 생성
- 프로세스 전환 발생 시 작업 내용을 PCB에 저장, 이후 다시 CPU 할당 시 PCB에 저장된 내용을 불러와 다시 작업 수행
- PCB 저장 내용
  1. 프로그램 식별자(PID): 프로세스 식별번호
  2. 프로세스 상태: new, ready, running, waiting, terminated 등의 상태 저장
  3. 프로그램 카운터: 프로세스가 다음에 실행할 명령어 주소
  4. CPU 레지스터
  5. CPU 스케쥴링 정보: 프로세스 우선순위, 스케쥴 큐에 대한 포인터 등
  6. 메모리 관리 정보: 페이지 테이블 또는 세그먼트 테이블 같은 정보 포함
  7. 입출력 상태 정보: 프로세스에 할당된 입출력 장치들 및 열린 파일 목록
  8. 어카운팅 정보: 사용된 CPI 시간, 시간 제한, 계정 정보 포함

### 스레드(Thread)

![thread](../image/os_thread.png)

- 프로세스 실행 단위
- 구성 요소
  1. 스레드 ID
  2. 프로그램 카운터(PC): 프로세스가 다음에 실행할 명령어 주소 저장
  3. 레지스터 집합들
  4. 스택: 함수 내 선언 변수, 복귀 주소, 매개변수 등 임시 변수 저장
- 서로 독립적인 스택을 가짐으로써 독립적인 함수 호출 및 실행 흐름을 가지는 것이 가능해짐

### Multi-Thread vs Multi-process
#### 멀티 스레딩
- 장점
  + 스레드 간의 통신이 필요한 경우 별도 자원을 사용하지 않고 공유하는 **Heap 영역**을 통해 데이터를 주고 받을 수 있어 **통신 방법이 훨씬 간단함.**
  + Context Switching의 경우 캐시 메모리를 비울 필요가 없어 매우 빠름
  + 시스템의 throughput이 향상되고 자원 소모가 줄어들며 응답시간이 빨라짐
- 단점
  + 서로 다른 스레드가 같은 힙 영역을 공유하기 때문에 다른 스레드가 사용 중인 자원에 접근해 엉뚱한 값을 읽거나  수정 가능
  + 이 때문에 **동기화** 작업 필요, 하지만 이로 인해 **병목 현상** 발생
  + 오류로 하나의 스레드가 종료 시 전체 스레드가 종료될 수 있음

#### 멀티 프로세싱
- 장점
  + 서로 독립된 프로세스에서 실행되므로 하나가 죽더라고 다른 프로세스에 영향을 끼치지 않음
- 단점
  + 많은 메모리 공간 및 CPU 시간 차지
  + Context Switching시 캐시 메모리를 비워야 함

#### 결론
- 속도가 빠른 것이 중요시될 시 멀티스레딩이 더 좋지만 공유 자원에 여러 스레드가 접근하는 경우가 많은 경우 오류가 발생할 가능성이 높아지므로 멀티 프로세스를 사용하는 것이 더 나을 수도 있음.
- 상황에 따라(안전 vs 속도) 적절한 동작 방식을 선택할 필요.

## Synchronization
### 정의
- 여러 프로세스 or 스레드가 공유하는 **자원의 일관성**을 유지하기 위한 활동
- 동기화가 없다면 Race Condition(2개 이상의 프로세스가 공통 자원을 병행하면서 읽을 시 순서에 따라 결과가 달라지는 현상)이 발생해 일관성이 깨진다.

### 임계 영역
- Critical Section: 실행 코드 중에 공유 데이터로 접근하는 코드
- 이 부분을 **동기화**를 통해 일관성을 유지시켜야 한다
- 임계 영역 문제 해결 충족 조건
  1. Mutual Exclusion(상호 배제): 하나의 프로세스가 임계 영역에 있으면 다른 프로세스는 못 들어간다
  2. Progress(진행): 임계 영역을 차지하는 프로세스가 없을 시 새로운 프로세스가 접근하면 들여보내준다
  3. Bounded Waiting(유한 대기): 임계 영역에 접근 요청 후 이가 받아들여질 때 까지의 시간은 유한해야 함


### 뮤텍스

![mutex](../image/os_mutex.png)

- MUTual EXclusion(상호 배제)의 약자
- **오직 하나**의 프로세스(스레드)만이 동일 시점에서 뮤텍스를 얻어 임계 영역 입장
- 임계 영역에 들어온 스레드만 락 해제 가능

### 세마포어

![semaphore](../image/os_semaphore.png)
- Lock을 걸지 않은 스레드도 Signal을 보내 락 해제 가능
- Wait & Signal 사용
  + wait 호출 시 세마포어 카운트 1 내림
  + signal 호출 시 카운트 1 증가
  + 카운트가 0보다 작아질 시 lock 실행
- 만약 초기 세마포어 카운트는 1로 설정 했을 시 뮤텍스와 같음, 즉 세마포어는 **뮤텍스가 될 수 있음**

### 스핀락

![spinlock](../image/os_spinlock.png)

- 다른 스레드가 Lock 소유 시 Sleep 하는 대신 lock가 반환될 때까지 계속 확인
- 보통 sleep하는 과정에서 context switching이 발생하므로 스핀락은 아주 작업에 대해 효율적이라 할 수 있음
- 하지만 얻을 때 까지 계속 돌리므로 Busy Waiting 문제로 CPU 오버헤드가 발생할 수 있는 문제점

### 모니터

![monitor](../image/os_monitor.png)

- 현재 많이 사용되고 있는 동기화 도구로, 세마포어보어 고수준 개념으로 알려져 있고 주로 Java에 사용됨
- 배타 동기, 조건 동기 이 2가지 Queue를 가짐
- 배타동기 Queue는 Synchronized 키워드를 통해 호출
- 조건동기 Queue는 wait(), notify(), notifyAll()로 호출
- 세마포어보다 코딩이 훨씬 쉬운데, 이는 항상 스레드가 들어오고 나가는 걸 명시해줘야하는 세마포어와 다르게 Synchronized 키워드만 붙이면 알아서 조절해준다.


## DeadLock

## 메모리 관리 기법

### 페이징

### 세그멘테이션

## OSI 7계층
